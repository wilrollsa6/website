<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Roll Statistics</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; margin: 2em; }
    #chart-container { width: 100%; max-width: 800px; margin: auto; }
    #controls { margin-bottom: 2em; text-align: center; }
  </style>
</head>
<body>
  <h1>Roll Statistics</h1>
  <div id="controls">
    <label for="timespan">Timespan:</label>
    <select id="timespan">
      <option value="day">Day</option>
      <option value="week">Week</option>
      <option value="month">Month</option>
      <option value="quarter">Quarter</option>
      <option value="year">Year</option>
    </select>
  </div>
  <div id="chart-container">
    <canvas id="rollChart"></canvas>
  </div>
  <script>
    // Robust parser for m/d/yy (or mm/dd/yy)
    function parseMDYY(str) {
      const parts = str.split('/');
      if (parts.length !== 3) return null;
      let [m, d, y] = parts.map(p => parseInt(p, 10));
      // Assume 2000+ for yy < 70, else 1900+
      y += (y < 70 ? 2000 : 1900);
      const date = new Date(y, m - 1, d);
      return isNaN(date) ? null : date;
    }

    async function fetchRollData() {
      try {
        const response = await fetch('rollData.txt');
        if (!response.ok) throw new Error('File not found');
        const text = await response.text();
        const lines = text.trim().split('\n');
        if (lines.length === 0 || (lines.length === 1 && lines[0] === "")) throw new Error('No data found');
        return lines;
      } catch (error) {
        document.getElementById('chart-container').innerHTML = `<div style="color: red; text-align: center;">Could not load data: ${error.message}</div>`;
        throw error;
      }
    }

    function parseRollData(lines) {
      const rawRecords = [];
      lines.forEach(line => {
        const columns = line.split(';');
        if (columns.length < 2) return;
        const dateStr = columns[0].trim();
        const rollColumn = columns[columns.length - 1].trim();
        const values = rollColumn.split(',').map(Number).filter(n => !isNaN(n));
        const sum = values.reduce((a, b) => a + b, 0);
        const date = parseMDYY(dateStr);
        if (date && !isNaN(date)) {
          rawRecords.push({ date, sum });
        }
      });
      return rawRecords;
    }

    // Generate all expected dates for a given period key and timespan
    function getDatesInPeriod(periodKey, timespan) {
      const parts = periodKey.split(/[-WQ]/);
      const year = parseInt(parts[0]);
      switch (timespan) {
        case 'day': {
          const [_, m, d] = periodKey.split('-');
          return [new Date(year, parseInt(m) - 1, parseInt(d))];
        }
        case 'week': {
          const week = parseInt(parts[1]);
          // ISO week starts on Monday
          // Find Monday of this ISO week
          const simple = new Date(year, 0, 1 + (week - 1) * 7);
          const dayOfWeek = simple.getDay();
          const monday = new Date(simple);
          monday.setDate(simple.getDate() - ((dayOfWeek + 6) % 7));
          return Array.from({ length: 7 }, (_, i) => new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + i));
        }
        case 'month': {
          const month = parseInt(parts[1]) - 1;
          const daysInMonth = new Date(year, month + 1, 0).getDate();
          return Array.from({ length: daysInMonth }, (_, i) => new Date(year, month, i + 1));
        }
        case 'quarter': {
          const quarter = parseInt(parts[1]);
          const firstMonth = (quarter - 1) * 3;
          let dates = [];
          for (let m = firstMonth; m < firstMonth + 3; m++) {
            const daysInMonth = new Date(year, m + 1, 0).getDate();
            for (let d = 1; d <= daysInMonth; d++) {
              dates.push(new Date(year, m, d));
            }
          }
          return dates;
        }
        case 'year': {
          let dates = [];
          for (let m = 0; m < 12; m++) {
            const daysInMonth = new Date(year, m + 1, 0).getDate();
            for (let d = 1; d <= daysInMonth; d++) {
              dates.push(new Date(year, m, d));
            }
          }
          return dates;
        }
        default:
          return [];
      }
    }

    function formatPeriodLabel(periodKey, timespan) {
      switch (timespan) {
        case 'day':
          return periodKey;
        case 'week':
          return periodKey;
        case 'month': {
          const [year, month] = periodKey.split('-');
          return `${year}-${month.padStart(2, '0')}`;
        }
        case 'quarter':
          return periodKey;
        case 'year':
          return periodKey;
        default:
          return periodKey;
      }
    }

    function getPeriodKey(date, timespan) {
      const year = date.getFullYear();
      const month = date.getMonth();
      const day = date.getDate();
      switch (timespan) {
        case 'day':
          return `${year}-${month + 1}-${day}`;
        case 'week': {
          // ISO week number
          const tempDate = new Date(date);
          tempDate.setHours(0, 0, 0, 0);
          tempDate.setDate(tempDate.getDate() + 4 - (tempDate.getDay() || 7));
          const yearStart = new Date(tempDate.getFullYear(), 0, 1);
          const weekNum = Math.ceil((((tempDate - yearStart) / 86400000) + 1) / 7);
          return `${year}-W${weekNum}`;
        }
        case 'month':
          return `${year}-${month + 1}`;
        case 'quarter':
          const quarter = Math.floor(month / 3) + 1;
          return `${year}-Q${quarter}`;
        case 'year':
          return `${year}`;
        default:
          return '';
      }
    }

    function groupRollData(records, timespan) {
      const periodSums = {};
      const datesByPeriod = {};
      const allDates = new Set(records.map(r => r.date.toDateString()));
      records.forEach(({ date, sum }) => {
        const key = getPeriodKey(date, timespan);
        periodSums[key] = (periodSums[key] || 0) + sum;
        datesByPeriod[key] = datesByPeriod[key] || new Set();
        datesByPeriod[key].add(date.toDateString());
      });

      // Sort keys chronologically
      let keys = Object.keys(periodSums);
      switch (timespan) {
        case 'day':
          keys.sort((a, b) => new Date(a) - new Date(b));
          break;
        case 'week':
          keys.sort((a, b) => {
            const [ay, aw] = a.split('-W').map(Number);
            const [by, bw] = b.split('-W').map(Number);
            return ay !== by ? ay - by : aw - bw;
          });
          break;
        case 'month':
          keys.sort((a, b) => {
            const [ay, am] = a.split('-').map(Number);
            const [by, bm] = b.split('-').map(Number);
            return ay !== by ? ay - by : am - bm;
          });
          break;
        case 'quarter':
          keys.sort((a, b) => {
            const [ay, aq] = a.split('-Q').map(Number);
            const [by, bq] = b.split('-Q').map(Number);
            return ay !== by ? ay - by : aq - bq;
          });
          break;
        case 'year':
          keys.sort((a, b) => Number(a) - Number(b));
          break;
      }

      // Compute completeness
      const today = new Date();
      today.setHours(0,0,0,0);
      const completeness = keys.map(key => {
        const expectedDates = getDatesInPeriod(key, timespan);
        // If any expected date is in the future, this period is incomplete
        const hasFuture = expectedDates.some(d => d > today);
        if (hasFuture) return false;
        // Otherwise, check if all expected days are present in the data
        return expectedDates.every(d => allDates.has(d.toDateString()));
      });

      return {
        labels: keys.map(k => formatPeriodLabel(k, timespan)),
        values: keys.map(k => periodSums[k]),
        completeness
      };
    }

    let chartInstance = null;
    let records = [];

    async function renderChart(timespan = 'day') {
      try {
        if (records.length === 0) {
          const lines = await fetchRollData();
          records = parseRollData(lines);
        }
        const { labels, values, completeness } = groupRollData(records, timespan);

        const ctx = document.getElementById('rollChart').getContext('2d');
        if (chartInstance) chartInstance.destroy();

        chartInstance = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: `Mileage (${timespan.charAt(0).toUpperCase() + timespan.slice(1)})`,
              data: values,
              borderColor: 'blue',
              borderWidth: 2,
              fill: false,
              pointRadius: 5,
              pointBackgroundColor: completeness.map(complete => complete ? 'blue' : 'orange'),
              pointBorderColor: completeness.map(complete => complete ? 'blue' : 'orange')
            }]
          },
          options: {
            plugins: {
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const idx = context.dataIndex;
                    const value = context.dataset.data[idx];
                    const label = context.chart.data.labels[idx];
                    if (!completeness[idx]) {
                      return `${label}: ${value} (Incomplete data for this timeframe)`;
                    } else {
                      return `${label}: ${value}`;
                    }
                  }
                }
              }
            },
            scales: {
              x: { title: { display: true, text: timespan.charAt(0).toUpperCase() + timespan.slice(1) } },
              y: { title: { display: true, text: 'Mileage' }, beginAtZero: true }
            }
          }
        });
      } catch (e) {
        // Error message already shown by fetchRollData
      }
    }

    document.getElementById('timespan').addEventListener('change', function() {
      renderChart(this.value);
    });

    renderChart();
  </script>
</body>
</html>
