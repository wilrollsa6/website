<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Roll Statistics</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; margin: 2em; }
    #chart-container { width: 100%; max-width: 800px; margin: auto; }
    #controls { margin-bottom: 2em; text-align: center; }
  </style>
</head>
<body>
  <h1>Roll Statistics</h1>
  <div id="controls">
    <label for="timespan">Timespan:</label>
    <select id="timespan">
      <option value="day">Day</option>
      <option value="week">Week</option>
      <option value="month">Month</option>
      <option value="quarter">Quarter</option>
      <option value="year">Year</option>
    </select>
  </div>
  <div id="chart-container">
    <canvas id="rollChart"></canvas>
  </div>
  <script>
    async function fetchRollData() {
      const response = await fetch('rollData.txt');
      const text = await response.text();
      return text.trim().split('\n');
    }

    function parseRollData(lines) {
      const rawRecords = [];
      lines.forEach(line => {
        const columns = line.split(';');
        if (columns.length < 2) return;
        const dateStr = columns[0].trim();
        const rollColumn = columns[columns.length - 1].trim();
        const values = rollColumn.split(',').map(Number).filter(n => !isNaN(n));
        const sum = values.reduce((a, b) => a + b, 0);
        const date = new Date(dateStr);
        if (!isNaN(date)) {
          rawRecords.push({ date, sum });
        }
      });
      return rawRecords;
    }

    // Generate all expected dates for a given period key and timespan
    function getDatesInPeriod(periodKey, timespan) {
      const parts = periodKey.split(/[-WQ]/);
      const year = parseInt(parts[0]);
      switch (timespan) {
        case 'day': {
          const [_, m, d] = periodKey.split('-');
          return [new Date(year, parseInt(m) - 1, parseInt(d))];
        }
        case 'week': {
          const week = parseInt(parts[1]);
          // ISO week starts on Monday
          const simple = new Date(year, 0, 1 + (week - 1) * 7);
          const dayOfWeek = simple.getDay();
          const monday = new Date(simple);
          monday.setDate(simple.getDate() - ((dayOfWeek + 6) % 7));
          return Array.from({ length: 7 }, (_, i) => new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + i));
        }
        case 'month': {
          const month = parseInt(parts[1]) - 1;
          const daysInMonth = new Date(year, month + 1, 0).getDate();
          return Array.from({ length: daysInMonth }, (_, i) => new Date(year, month, i + 1));
        }
        case 'quarter': {
          const quarter = parseInt(parts[1]);
          const firstMonth = (quarter - 1) * 3;
          let dates = [];
          for (let m = firstMonth; m < firstMonth + 3; m++) {
            const daysInMonth = new Date(year, m + 1, 0).getDate();
            for (let d = 1; d <= daysInMonth; d++) {
              dates.push(new Date(year, m, d));
            }
          }
          return dates;
        }
        case 'year': {
          let dates = [];
          for (let m = 0; m < 12; m++) {
            const daysInMonth = new Date(year, m + 1, 0).getDate();
            for (let d = 1; d <= daysInMonth; d++) {
              dates.push(new Date(year, m, d));
            }
          }
          return dates;
        }
        default:
          return [];
      }
    }

    function formatPeriodLabel(periodKey, timespan) {
      switch (timespan) {
        case 'day':
          return periodKey;
        case 'week':
          return periodKey;
        case 'month': {
          const [year, month] = periodKey.split('-');
          return `${year}-${month.padStart(2, '0')}`;
        }
        case 'quarter':
          return periodKey;
        case 'year':
          return periodKey;
        default:
          return periodKey;
      }
    }

    function groupRollData(records, timespan) {
      const periodSums = {};
      const datesByPeriod = {};
      const allDates = new Set(records.map(r => r.date.toDateString()));
      records.forEach(({ date, sum }) => {
        const key = getPeriodKey(date, timespan);
        periodSums[key] = (periodSums[key] || 0) + sum;
        datesByPeriod[key] = datesByPeriod[key] || new Set();
        datesByPeriod[key].add(date.toDateString());
      });

      // Sort keys chronologically
      let keys = Object.keys(periodSums);
      switch (timespan) {
        case 'day':
          keys.sort((a, b) => new Date(a) - new Date(b));
          break;
        case 'week':
          keys.sort((a, b) => {
            const [ay, aw] = a.split('-W').map(Number);
            const [by, bw] = b.split('-W').map(Number);
            return ay !== by ? ay - by : aw - bw;
          });
          break;
        case 'month':
          keys.sort((a, b) => {
            const [ay, am] = a.split('-').map(Number);
            const [by, bm] = b.split('-').map(Number);
            return ay !== by ? ay - by : am - bm;
          });
          break;
        case 'quarter':
          keys.sort((a, b) => {
            const [ay, aq] = a.split('-Q').map(Number);
            const [by, bq] = b.split('-Q').map(Number);
            return ay !== by ? ay - by : aq - bq;
          });
          break;
        case 'year':
          keys.sort((a, b) => Number(a) - Number(b));
          break;
      }

      // Compute completeness
      const today = new Date();
      today.setHours(0,0,0,0);
      const completeness = keys.map(key => {
        const expectedDates = getDatesInPeriod(key, timespan);
        // If any expected date is in the future, this period is incomplete
        const hasFuture = expectedDates.some(d => d > today);
        if (hasFuture) return false;
        // Otherwise, check if all expected days are present in the data
        return expectedDates.every(d => allDates.has(d.toDateString()));
      });

      return {
        labels: keys.map(k => formatPeriodLabel(k, timespan)),
        values: keys.map(k => periodSums[k]),
        completeness
      };
    }

    let chartInstance = null;
    let records = [];

    async function renderChart(timespan = 'day') {
      if (records.length === 0) {
        const lines = await fetchRollData();
        records = parseRollData(lines);
      }
      const { labels, values, completeness } = groupRollData(records, timespan);

      const ctx = document.getElementById('rollChart').getContext('2d');
      if (chartInstance) chartInstance.destroy();
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: `Mileage (${timespan.charAt(0).toUpperCase() + timespan.slice(1)})`,
            data: values,
            borderColor: 'blue',
            borderWidth: 2,
            fill: false,
            pointRadius: 5,
            pointBackgroundColor: completeness.map(complete => complete ? 'blue' : 'orange'),
            pointBorderColor: completeness.map(complete => complete ? 'blue' : 'orange')
          }]
        },
        options: {
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  const idx = context.dataIndex;
                  const value = context.dataset.data[idx];
                  const label = context.chart.data.labels[idx];
                  if (!completeness[idx]) {
                    return `${label}: ${value} (Incomplete data for this timeframe)`;
                  } else {
                    return `${label}: ${value}`;
                  }
                }
              }
            }
          },
          scales: {
            x: { title: { display: true, text: timespan.charAt(0).toUpperCase() + timespan.slice(1) } },
            y: { title: { display: true, text: 'Mileage' }, beginAtZero: true }
          }
        }
      });
    }

    document.getElementById('timespan').addEventListener('change', function() {
      renderChart(this.value);
    });

    renderChart();
  </script>
</body>
</html>
